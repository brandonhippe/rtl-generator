"""
Handle RTL generation
"""
# Necessary imports, path setup, and global variables
import argparse
import os
import re

import prettytable

from .arguments import get_arguments


#####################################################################################################
# Base methods needed for all RTL generators                                                        #
#####################################################################################################
def fill_in_template(template: str, args: argparse.Namespace | None, scope: dict, regex_str: str=r"#{\((\w+?)\)}") -> str:
    """
    Fill in the template with the arguments and variables.

    Matches using the regex "#{((\w+?))}".

    Looks for the key in the arguments, variables, and global functions, in that order.
    """
    if 'args' not in scope:
        scope['args'] = args

    if 'used_args' not in scope:
        scope['used_args'] = set()

    while key_match := re.search(regex_str, template):
        start, end = key_match.span()
        indent_amt = start - template.rfind('\n', 0, start) - 1

        get_arguments(scope, [key_match.group(1)])
        if key_match.group(1) in scope:
            # Key is a variable or function in this file
            if callable(scope[key_match.group(1)]):
                replace_with = scope[key_match.group(1)](scope)
            else:
                replace_with = str(scope[key_match.group(1)])
        else:
            # This will raise an error if the key is not a defined variable or a function in the global scope
            try:
                if callable(globals()[key_match.group(1)]):
                    replace_with = globals()[key_match.group(1)](scope)
                else:
                    replace_with = str(globals()[key_match.group(1)])
            except KeyError:
                raise KeyError(f"No way to fill template key: {key_match.group(1)}")

        if replace_with.count('\n') > 0:
            replace_with = replace_with.replace('\n', '\n' + " " * indent_amt)
        template = template[:start] + replace_with + template[end:]

    return template


def rtl_generator(rtl_name: str, pretty_rtl_name: str, args: argparse.Namespace, scope: dict, include_output_filename: bool=True) -> str:
    """
    Generate RTL code
    """
    print("\n" + "-" * os.get_terminal_size().columns)
    print(f"Generating RTL for module: {pretty_rtl_name}")
    
    init_msg = f"/*\n    This file generated by rtl-generator, written by Brandon Hippe\n    Arguments:\n"

    with open(f"template_{rtl_name}.sv", "r", encoding='UTF-8') as f:
        template = f.read()

    used_args = set()
    if include_output_filename:
        used_args.add(f"{rtl_name}_output")
    scope['used_args'] = used_args
    generated = fill_in_template(template, args, scope)

    print("\nArguments:")
    arg_table = prettytable.PrettyTable()
    arg_table.field_names = ["Argument", "Value"]
    for arg, value in [(a, vars(args)[a]) for a in used_args if a != f"{rtl_name}_output" or include_output_filename]:
        arg_table.add_row([arg, value])

    print(arg_table)
    arg_table = arg_table.get_string().split('\n')
    init_msg += '\n'.join([("    " + line) for line in arg_table]) + "\n*/\n\n"

    print(f"\nFinished generating RTL for module: {pretty_rtl_name}")

    return init_msg + generated
