"""
Handle RTL generation
"""
# Necessary imports, path setup, and global variables
import argparse
import os
import re

import prettytable

from .arguments import get_arguments
from .format import get_pretty_name


# DEFAULT_REGEX = re.compile(r"//!? .*?<(\w*)\b[^>]*>(.*?)// </\1>", re.MULTILINE | re.DOTALL)
DEFAULT_REGEX = re.compile(r"#{\((\w+?)\)}")

#####################################################################################################
# Base methods needed for all RTL generators                                                        #
#####################################################################################################
def fill_in_template(template: str, args: argparse.Namespace | None, scope: dict, match_regex: re.Pattern=DEFAULT_REGEX) -> str:
    """
    Fill in the template with the arguments and variables.

    Matches using the regex "#{((\w+?))}".

    Looks for the key in the arguments, variables, and global functions, in that order.
    """
    if 'args' not in scope:
        scope['args'] = args

    if 'used_args' not in scope:
        scope['used_args'] = set()

    while key_match := match_regex.search(template):
        if len(key_match.groups()) > 2:
            start, end = key_match.span(2)
        else:
            start, end = key_match.span()
        indent_amt = start - template.rfind('\n', 0, start) - 1

        get_arguments(scope, [key_match.group(1)])
        if key_match.group(1) in scope:
            # Key is a variable or function in this file
            if callable(scope[key_match.group(1)]):
                replace_with = scope[key_match.group(1)](scope)
            else:
                replace_with = str(scope[key_match.group(1)])
        else:
            # This will raise an error if the key is not a defined variable or a function in the global scope
            try:
                if callable(globals()[key_match.group(1)]):
                    replace_with = globals()[key_match.group(1)](scope)
                else:
                    replace_with = str(globals()[key_match.group(1)])
            except KeyError:
                raise KeyError(f"No way to fill template key: {key_match.group(1)}")

        if replace_with.count('\n') > 0:
            replace_with = replace_with.replace('\n', '\n' + " " * indent_amt)
        template = template[:start] + replace_with + template[end:]

    return template


def param_table(scope: dict) -> str:
    """
    Include the used arguments table
    """
    key_match = getattr(scope, "key_match")
    table_replace_str = key_match.group(0)
    scope['table_replace_str'] = table_replace_str

    if len(key_match.groups()) > 2:
        return key_match.group(2)

    return table_replace_str


def rtl_generator(rtl_name: str, args: argparse.Namespace, scope: dict) -> str:
    """
    Generate RTL code
    """
    print("\n" + "-" * os.get_terminal_size().columns)
    print(f"Generating RTL for module: {get_pretty_name(rtl_name)}")
    
    init_msg = f"//! This file generated by [rtl-generator](https://github.com/brandonhippe/rtl-generator.git), written by Brandon Hippe\n\n//! Arguments:\n"

    with open(getattr(args, f"{rtl_name}_input"), "r", encoding='UTF-8') as f:
        template = f.read()

    template.replace(init_msg, "")

    used_args = set()
    scope['used_args'] = used_args
    generated = fill_in_template(template, args, scope)

    print("\nArguments:")
    arg_table = prettytable.PrettyTable()
    arg_table.field_names = ["Argument", "Value"]
    for arg, value in sorted([(a, vars(args)[a]) for a in used_args]):
        arg_table.add_row([arg, value])

    arg_table.set_style(prettytable.MARKDOWN)
    arg_table_str = arg_table.get_string().splitlines()

    if table_replace_str := scope.get('table_replace_str', None):
        parameter_table = '\n'.join(map(lambda l: f"//!     {l}", arg_table_str)) + "\n\n"
        generated = generated.replace(table_replace_str, parameter_table)

    arg_table.add_row([f"{rtl_name}_output", getattr(args, f"{rtl_name}_output")])
    arg_table.set_style(prettytable.DOUBLE_BORDER)
    print(arg_table.get_string())

    print(f"\nFinished generating RTL for module: {get_pretty_name(rtl_name)}")

    return init_msg + generated
